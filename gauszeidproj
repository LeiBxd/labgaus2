package gauszeidproj;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LinearEquationSystem {

    private int size; // Размерность системы уравнений
    private double[][] matrix; // Матрица системы уравнений
    private double[] rightHandSides; // Правые части системы уравнений
    private double[] solution; // Решение системы уравнений

    public LinearEquationSystem(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        size = Integer.parseInt(reader.readLine()); // Считываем размерность системы
        matrix = new double[size][size];
        rightHandSides = new double[size];
        for (int i = 0; i < size; i++) {
            String[] line = reader.readLine().split(" "); // Считываем строку из файлаи разбиваем ее на отдельные значения
            for (int j = 0; j < size; j++) {
                matrix[i][j] = Double.parseDouble(line[j]); // Коэффициенты матрицы
            }
            rightHandSides[i] = Double.parseDouble(line[size]); // Правые части
        }
        reader.close();
    }

    public boolean solve(double epsilon, int maxIterations) {
        //1)Вначале метод вызывает метод findPermutation(), который проверяет, нужна ли перестановка строк матрицы, чтобы решить систему.
        //2) Если перестановка строк необходима, метод findPermutation() возвращает массив permutation, который содержит индексы строк, которые нужно поменять местами. Если систему нельзя решить итерационным методом, метод findPermutation() возвращает null, и метод solve() выводит сообщение об ошибке и возвращает false.
        //3)Затем метод solve() вызывает метод checkConvergence(), который проверяет, сходится ли метод Гаусса — Зейделя для данной системы уравнений. Если метод расходится, метод solve() выводит сообщение об ошибке и возвращает false.
        //4)Далее, если перестановка строк необходима, метод solve() вызывает метод permuteRows(), который меняет местами строки матрицы и правые части уравнений в соответствии с массивом permutation.
        //5)Затем метод solve() начинает итерироваться до тех пор, пока не будет найдено решение или не будет достигнуто максимальное количество итераций.
        //6)Если точность достигнута, метод сохраняет новое приближение в переменной solution и возвращает true. Если точность не достигнута, метод проверяет, убывает ли последовательность разностей между предыдущим и текущим приближениями, и если нет, выводит сообщение об ошибке и возвращает false.
        //7)В конце метод solve() возвращает false, если решение не найдено. Переменная solution содержит найденное приближение решения, которое можно получитьчерез вызов метода getSolution().

    private int[] findPermutation() { // Перестановка строк, если нужно
        //1)Если в матрице есть нули на диагонали, то метод ищет строку, в которой на диагонали нет нулей, и меняет ее местами с текущей строкой.
        //2)Если такую строку найти невозможно, то метод возвращает null, что означает, что систему нельзя решить итерационным методом.
        //3)Если нулей на диагонали нет, метод возвращает массив индексов строк, которые не нужно менять местами, так как систему можно решить без перестановки строк.
        //4)Если в матрице есть нули на диагонали и есть строка, в которой на диагонали нет нулей, метод создает начальную перестановку, в которой все индексы строк идут по порядку.
        //5)Затем метод ищет строки, в которых на диагонали есть нули, и меняет их местами с другими строками, в которых на диагонали нет нулей. При этом метод также меняет индексы строк в массиве перестановки.
        //6)В результате метод возвращает массив индексов строк, который указывает, в каком порядке нужно переставить строки матрицы, чтобы систему можно было решить итерационным методом.

    private boolean checkConvergence(int[] permutation) { // Проверка на сходимость
        //1)метод вычисляет для каждой строки матрицы сумму модулей всех ее элементов, кроме диагонального элемента
            //2) Затем метод проверяет, выполнено ли условие сходимости для каждой строки матрицы: модуль диагонального элемента должен быть больше суммы модулей остальных элементов строки
            //3)Если хотя бы для одной строки это условие не выполняется, метод возвращает false, что означает, что метод Гаусса — Зейделя не сходится для данной системы.
            //4)Если условие сходимости выполняется для всех строк матрицы, метод возвращает true, что означает, что метод Гаусса — Зейделя сходится для данной системы.

    private void permuteRows(int[] permutation) { // Перестановка строк
        //1)меняет местами строки матрицы и правые части уравнений в соответствии с массивом permutation. Если массив permutation равен null, то метод ничего не делает.
                //2)Если массив permutation не равен null, метод создает новую матрицу newMatrix и новый вектор правых частей newRightHandSides.
                //3)Затем метод копирует строки матрицы и правые части уравнений из исходной матрицы и вектора в новые матрицу и вектор, используя индексы из массива permutation
                //4) Таким образом, строки и правые части уравнений переставляются в соответствии с порядком, указанным в массиве permutation.
                //5)В конце метод заменяет исходную матрицу и вектор правых частей на новые матрицу и вектор, соответственно.

    private boolean checkSolution(double[] newSolution, double epsilon) { // Проверка на достижение необходимой точности
      //1)проверяет, достигнута ли необходимая точность решения системы линейных уравнений.
                    //2)Метод вычисляет для каждой переменной разницу между ее предыдущим значением в переменной solution и новым значением в newSolution. Если разница больше, чем epsilon, метод возвращает false
                    //3)Если разница меньше или равна epsilon для каждой переменной, метод возвращает true, что означает, что достигнута необходимая точность решения.


    private boolean checkDecreasing(double[] differences) { // Проверка на убывание разностей между предыдущим и текущим приближениями
                            //1)проверяет, убывают ли разности между предыдущим и текущим приближениями решения системы линейных уравнений.
                        //2)Метод принимает на вход массив differences, который содержит разности между предыдущим и текущим приближениями решения.
                        //3)Метод сравнивает каждый элемент массива differences с предыдущим элементом и возвращает false, если хотя бы один элемент больше или равен предыдущему элементу. Если все элементы массива differences удовлетворяют условию убывания, метод возвращает true.
                        //4)Если разности между предыдущим и текущим приближениями убывают, то это означает, что метод Гаусса-Зейделя сходится к решению системы линейных уравнений.

    private void swapRows(int i, int j){ // Меняем местами строки матрицы
                //1)
                            // 2)Метод создает временный массив tempRow и копирует в него содержимое строки с индексом i. Затем метод копирует содержимое строки с индексом j в строку с индексом i.
                            //3)Наконец, метод копирует содержимое временного массива tempRow в строку с индексом j. Таким образом, метод меняет местами содержимое строк с индексами i и j.
                           
                            }

    public void printSolution() {
                            }

    public void printSystem() {
                            }
class Main {

    public static void main(String[] args) throws IOException {
    }
}
